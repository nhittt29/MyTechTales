[{"content":"1. Giới thiệu Đa tuyến (multithreading) là kỹ thuật cho phép một chương trình Java xử lý nhiều tác vụ đồng thời, rất quan trọng trong lập trình mạng.\nVí dụ, một server cần phục vụ hàng trăm client cùng lúc mà không bị tắc nghẽn.\nBài viết này, được cập nhật vào sáng ngày 16/10/2025 lúc 09:23 AM +07, sẽ giải thích cách triển khai đa tuyến, ưu điểm, thách thức, và ứng dụng trong mạng.\n2. Vai trò của đa tuyến trong lập trình mạng Xử lý đa kết nối: Mỗi client được gán một thread riêng để xử lý độc lập. Tăng hiệu suất: Server không phải chờ đợi, đáp ứng nhanh hơn với nhiều yêu cầu. Ứng dụng thời gian thực: Hỗ trợ chat, game online, hoặc giám sát mạng cần phản hồi tức thì. Mở rộng quy mô: Dễ dàng nâng cấp server để phục vụ lượng lớn người dùng. 3. Cách thực hiện đa tuyến trong Java Java cung cấp nhiều cách để triển khai đa tuyến, tùy thuộc vào yêu cầu ứng dụng:\nSử dụng Thread: Tạo thread mới cho mỗi tác vụ (kéo dài vòng đời thread). Runnable: Triển khai interface Runnable để định nghĩa tác vụ, linh hoạt hơn Thread. ThreadPool: Sử dụng ExecutorService để quản lý số lượng thread, tránh quá tải hệ thống. Callable/Future: Hỗ trợ trả về kết quả từ thread, phù hợp cho tác vụ phức tạp. 4. Ưu điểm và thách thức Ưu điểm: Tối ưu hóa tài nguyên CPU bằng cách chạy song song. Cải thiện trải nghiệm người dùng với phản hồi nhanh. Thách thức: Đồng bộ hóa: Nhiều thread truy cập chung dữ liệu có thể gây xung đột (sử dụng synchronized). Quản lý: Số lượng thread lớn tiêu tốn bộ nhớ, cần giới hạn bằng ThreadPool. Deadlock: Nguy cơ xảy ra khi thread chờ nhau vô thời hạn. 5. Ứng dụng thực tế Server chat đa người dùng: Mỗi người dùng chạy trên thread riêng, hỗ trợ tin nhắn nhóm. Dịch vụ mạng thời gian thực: Cập nhật dữ liệu liên tục như bảng giá chứng khoán. Game online: Đồng bộ trạng thái giữa người chơi qua nhiều thread. Hệ thống giám sát: Theo dõi lưu lượng mạng trên nhiều kết nối cùng lúc. 6. Ví dụ minh họa Dưới đây là ví dụ server đa tuyến sử dụng ThreadPool để xử lý nhiều client:\nimport java.io.*; import java.net.*; import java.util.concurrent.*; public class MultiThreadServer { public static void main(String[] args) throws IOException { ServerSocket server = new ServerSocket(1234); System.out.println(\u0026#34;Server đa tuyến đang lắng nghe trên cổng 1234, cập nhật 16/10/2025 09:23 AM +07...\u0026#34;); // Tạo ThreadPool với 10 thread ExecutorService executor = Executors.newFixedThreadPool(10); while (true) { Socket client = server.accept(); System.out.println(\u0026#34;Kết nối mới từ: \u0026#34; + client.getInetAddress()); executor.execute(() -\u0026gt; { try (BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream())); PrintWriter out = new PrintWriter(client.getOutputStream(), true)) { String message; while ((message = in.readLine()) != null) { System.out.println(\u0026#34;Nhận từ \u0026#34; + client.getInetAddress() + \u0026#34;: \u0026#34; + message); out.println(\u0026#34;Echo: \u0026#34; + message.toUpperCase()); } } catch (IOException e) { System.out.println(\u0026#34;Lỗi thread: \u0026#34; + e.getMessage()); } }); } } } ","permalink":"https://nhittt29.github.io/MyTechTales/blog/java/multithreading/","summary":"Tìm hiểu cách sử dụng đa tuyến (multithreading) để xử lý nhiều kết nối mạng cùng lúc trong Java, cập nhật ngày 16/10/2025.","title":"Lập trình đa tuyến"},{"content":"1. Giới thiệu TCP (Transmission Control Protocol) là giao thức mạng đảm bảo truyền dữ liệu đáng tin cậy qua Internet hoặc mạng nội bộ.\nJava sử dụng lớp Socket và ServerSocket để triển khai TCP, phù hợp cho các ứng dụng cần độ chính xác cao như truyền file hoặc chat.\nBài viết này, được cập nhật vào sáng thứ Năm, ngày 16/10/2025 lúc 09:30 AM +07, sẽ hướng dẫn chi tiết cách lập trình socket TCP trong Java.\n2. Vai trò của giao thức TCP trong lập trình mạng Đảm bảo dữ liệu: Không mất gói tin, không trùng lặp, và đúng thứ tự. Kết nối ổn định: Thích hợp cho truyền file lớn hoặc giao tiếp liên tục. Xác nhận: Client và server xác nhận lẫn nhau trước khi truyền, tăng độ tin cậy. Ứng dụng quan trọng: Hỗ trợ các dịch vụ như HTTP, FTP, và SMTP. 3. Cách lập trình socket TCP trong Java Java cung cấp các bước cơ bản để lập trình socket TCP:\nServer: Tạo ServerSocket và lắng nghe trên cổng cụ thể (ví dụ: 1234). Chấp nhận kết nối từ client qua accept(). Client: Kết nối đến server qua Socket với địa chỉ IP và cổng. Giao tiếp: Sử dụng InputStream và OutputStream (hoặc Reader/Writer) để gửi/nhận dữ liệu. 4. Ưu điểm và hạn chế Ưu điểm: Độ tin cậy cao, không mất dữ liệu. Phù hợp cho ứng dụng cần kết nối lâu dài. Hạn chế: Tốc độ chậm hơn UDP do cần xác nhận và sắp xếp gói tin. Tiêu tốn tài nguyên hơn khi xử lý nhiều kết nối đồng thời. 5. Ứng dụng thực tế Gửi email qua mạng: Giao thức SMTP dùng TCP để truyền email an toàn. Ứng dụng chat an toàn: Truyền tin nhắn không mất mát, như Zalo hoặc WhatsApp. Truyền file lớn: Đảm bảo toàn vẹn dữ liệu khi tải lên/tai xuống. Web server: HTTP dựa trên TCP để phục vụ trang web. 6. Ví dụ minh họa Dưới đây là ví dụ client-server TCP cơ bản với xử lý ngoại lệ và phản hồi:\nimport java.io.*; import java.net.*; public class TCPServer { public static void main(String[] args) { try (ServerSocket server = new ServerSocket(1234)) { System.out.println(\u0026#34;Server TCP đang lắng nghe trên cổng 1234, cập nhật 16/10/2025 09:30 AM +07...\u0026#34;); while (true) { try (Socket client = server.accept()) { System.out.println(\u0026#34;Kết nối từ: \u0026#34; + client.getInetAddress()); // Đọc dữ liệu từ client BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream())); String message = in.readLine(); System.out.println(\u0026#34;Nhận từ client: \u0026#34; + message); // Gửi phản hồi PrintWriter out = new PrintWriter(client.getOutputStream(), true); out.println(\u0026#34;Server phản hồi: \u0026#34; + message.toUpperCase() + \u0026#34; vào \u0026#34; + new Date()); } catch (IOException e) { System.out.println(\u0026#34;Lỗi kết nối: \u0026#34; + e.getMessage()); } } } catch (IOException e) { System.out.println(\u0026#34;Lỗi khởi tạo server: \u0026#34; + e.getMessage()); } } } class TCPClient { public static void main(String[] args) { try (Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 1234)) { // Gửi dữ liệu đến server PrintWriter out = new PrintWriter(socket.getOutputStream(), true); out.println(\u0026#34;Xin chào từ client vào \u0026#34; + new Date()); // Nhận phản hồi BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream())); String response = in.readLine(); System.out.println(\u0026#34;Phản hồi từ server: \u0026#34; + response); } catch (IOException e) { System.out.println(\u0026#34;Lỗi client: \u0026#34; + e.getMessage()); } } } ","permalink":"https://nhittt29.github.io/MyTechTales/blog/java/tcp-socket/","summary":"Hướng dẫn lập trình socket sử dụng giao thức TCP trong Java, từ cơ bản đến ứng dụng nâng cao, cập nhật ngày 16/10/2025.","title":"Lập trình socket cho giao thức TCP"},{"content":"1. Giới thiệu Luồng nhập xuất (Input/Output - I/O) là quá trình xử lý dữ liệu giữa các thiết bị hoặc qua mạng trong Java.\nTrong lập trình mạng, I/O đóng vai trò quan trọng để gửi và nhận thông tin giữa client và server một cách hiệu quả.\nBài viết này, được cập nhật vào sáng ngày 16/10/2025 lúc 09:20 AM +07, sẽ giải thích cách quản lý luồng, các loại luồng, phương pháp tối ưu, và ứng dụng thực tế.\n2. Vai trò của luồng nhập xuất trong mạng Nhận dữ liệu: Đọc thông tin từ socket, file, hoặc nguồn dữ liệu qua mạng. Gửi dữ liệu: Truyền phản hồi, file, hoặc lệnh điều khiển đến client. Hiệu suất: Quản lý luồng đúng cách giúp tránh nghẽn mạng, mất dữ liệu, hoặc tiêu tốn tài nguyên không cần thiết. Thời gian thực: Hỗ trợ các ứng dụng như streaming hoặc chat cần xử lý dữ liệu liên tục. 3. Các loại luồng trong Java Java cung cấp nhiều loại luồng để xử lý dữ liệu, mỗi loại phù hợp với mục đích khác nhau:\nInputStream: Đọc dữ liệu thô từ nguồn (ví dụ: socket, file). FileInputStream: Đọc file cục bộ. BufferedInputStream: Tăng tốc độ đọc bằng bộ đệm. OutputStream: Gửi dữ liệu đến đích. FileOutputStream: Ghi vào file. PrintWriter: Hỗ trợ ghi chuỗi dễ dàng, thường dùng trong socket. Reader/Writer: Xử lý dữ liệu ký tự (Unicode), phù hợp với văn bản. BufferedReader: Đọc dòng văn bản hiệu quả. PrintWriter: Ghi văn bản với định dạng tốt. 4. Cách quản lý luồng hiệu quả Để đảm bảo ứng dụng mạng hoạt động ổn định, cần áp dụng các kỹ thuật sau:\nMở và đóng luồng: Luôn gọi phương thức close() sau khi sử dụng để giải phóng tài nguyên. Sử dụng try-with-resources để tự động đóng. Xử lý ngoại lệ: Áp dụng try-catch để bắt lỗi IOException, tránh crash ứng dụng. Sử dụng buffer: Bộ đệm (BufferedReader/BufferedWriter) giảm số lần truy cập I/O, tăng hiệu suất. Kiểm tra trạng thái: Đảm bảo socket hoặc luồng còn hoạt động trước khi đọc/ghi. 5. Ứng dụng thực tế Nhận file qua mạng: Tải tệp từ server về client, ví dụ: cập nhật phần mềm. Gửi lệnh điều khiển: Truyền thông tin cấu hình qua socket, như điều chỉnh server từ xa. Dịch vụ streaming: Phát video hoặc âm thanh qua mạng, yêu cầu I/O liên tục. Log hệ thống: Ghi nhật ký hoạt động mạng vào file để phân tích. 6. Ví dụ minh họa Dưới đây là ví dụ server nhận dữ liệu từ client qua luồng, với xử lý ngoại lệ và bộ đệm:\nimport java.io.*; import java.net.*; public class IOStreamDemo { public static void main(String[] args) { try (ServerSocket server = new ServerSocket(1234)) { System.out.println(\u0026#34;Server đang lắng nghe trên cổng 1234, cập nhật 16/10/2025 09:20 AM +07...\u0026#34;); while (true) { try (Socket socket = server.accept()) { System.out.println(\u0026#34;Kết nối từ: \u0026#34; + socket.getInetAddress()); // Đọc dữ liệu từ client BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); String message = reader.readLine(); System.out.println(\u0026#34;Nhận từ client: \u0026#34; + message); // Gửi phản hồi PrintWriter out = new PrintWriter(socket.getOutputStream(), true); out.println(\u0026#34;Server đã nhận: \u0026#34; + message + \u0026#34; vào \u0026#34; + new java.util.Date()); } catch (IOException e) { System.out.println(\u0026#34;Lỗi kết nối: \u0026#34; + e.getMessage()); } } } catch (IOException e) { System.out.println(\u0026#34;Lỗi khởi tạo server: \u0026#34; + e.getMessage()); } } } ","permalink":"https://nhittt29.github.io/MyTechTales/blog/java/io-streams/","summary":"Hướng dẫn chi tiết về quản lý luồng nhập xuất (I/O) trong lập trình mạng bằng Java, từ cơ bản đến ứng dụng nâng cao, cập nhật ngày 16/10/2025.","title":"Quản lý các luồng nhập xuất"},{"content":"1. Giới thiệu Quản lý dịch vụ kết nối mạng là quá trình đảm bảo server hoạt động ổn định, đáp ứng yêu cầu từ client một cách hiệu quả.\nJava cung cấp các công cụ như ServerSocket, phương pháp timeout, và thread để kiểm soát kết nối mạng.\nBài viết này, được cập nhật vào sáng ngày 16/10/2025 lúc 09:27 AM +07, sẽ hướng dẫn toàn diện về quản lý dịch vụ mạng trong Java.\n2. Vai trò của quản lý dịch vụ kết nối mạng Theo dõi trạng thái: Kiểm tra xem kết nối có hoạt động không, phát hiện lỗi kịp thời. Phân phối tải: Điều hướng client đến server phù hợp để tránh quá tải. Bảo trì: Ngắt kết nối không ổn định hoặc xử lý sự cố mạng. Mở rộng quy mô: Hỗ trợ tăng cường tài nguyên khi số lượng người dùng tăng cao. 3. Các phương pháp quản lý Java cung cấp nhiều kỹ thuật để quản lý dịch vụ kết nối mạng:\nLắng nghe kết nối: Sử dụng ServerSocket với cổng cố định (ví dụ: 1234) để nhận yêu cầu. Timeout: Đặt giới hạn thời gian chờ (setSoTimeout) để tránh treo server. Đồng bộ hóa: Quản lý nhiều kết nối đồng thời với thread hoặc ThreadPool. Ghi log: Theo dõi hoạt động kết nối để phân tích và debug. 4. Ưu điểm của quản lý tốt Độ tin cậy: Server hoạt động liên tục, giảm thời gian chết. Hiệu suất: Phân phối tải hợp lý, tránh nghẽn mạng. Khả năng mở rộng: Dễ dàng nâng cấp hệ thống khi nhu cầu tăng. Bảo mật: Phát hiện và xử lý kết nối bất thường (ví dụ: tấn công DDoS). 5. Ứng dụng thực tế Server web đa kết nối: Xử lý hàng nghìn yêu cầu từ người dùng cùng lúc, như website thương mại điện tử. Hệ thống giám sát mạng: Theo dõi lưu lượng, phát hiện lỗi hoặc tấn công mạng. Dịch vụ đám mây: Quản lý kết nối từ nhiều vùng địa lý, ví dụ: AWS hoặc Google Cloud. Ứng dụng IoT: Điều khiển thiết bị từ xa qua mạng. 6. Ví dụ minh họa Dưới đây là ví dụ server với quản lý timeout, log kết nối, và xử lý ngoại lệ:\nimport java.io.*; import java.net.*; import java.util.Date; public class ServiceManager { public static void main(String[] args) { try (ServerSocket server = new ServerSocket(1234)) { server.setSoTimeout(10000); // 10 giây timeout System.out.println(\u0026#34;Server đang lắng nghe trên cổng 1234, cập nhật 16/10/2025 09:27 AM +07...\u0026#34;); while (true) { try (Socket client = server.accept()) { System.out.println(\u0026#34;Kết nối từ: \u0026#34; + client.getInetAddress() + \u0026#34; tại \u0026#34; + new Date()); // Đọc dữ liệu từ client BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream())); String message = in.readLine(); System.out.println(\u0026#34;Nhận: \u0026#34; + message); // Gửi phản hồi PrintWriter out = new PrintWriter(client.getOutputStream(), true); out.println(\u0026#34;Server phản hồi: \u0026#34; + message + \u0026#34; vào \u0026#34; + new Date()); } catch (SocketTimeoutException e) { System.out.println(\u0026#34;Timeout sau 10 giây, tiếp tục lắng nghe...\u0026#34;); } catch (IOException e) { System.out.println(\u0026#34;Lỗi kết nối: \u0026#34; + e.getMessage()); } } } catch (IOException e) { System.out.println(\u0026#34;Lỗi khởi tạo server: \u0026#34; + e.getMessage()); } } } ","permalink":"https://nhittt29.github.io/MyTechTales/blog/java/network-services/","summary":"Hướng dẫn chi tiết cách quản lý dịch vụ kết nối mạng hiệu quả trong Java, từ giám sát đến tối ưu hóa, cập nhật ngày 16/10/2025.","title":"Quản lý dịch vụ kết nối mạng"},{"content":"1. Giới thiệu Lập trình mạng là lĩnh vực quan trọng trong phát triển phần mềm, cho phép các ứng dụng giao tiếp với nhau qua Internet hoặc mạng nội bộ (LAN).\nJava, với các thư viện mạng tích hợp sẵn như java.net, trở thành ngôn ngữ lý tưởng để xây dựng các ứng dụng mạng nhờ tính ổn định và khả năng tương thích cao.\nBài viết này sẽ giới thiệu các khái niệm cơ bản, vai trò, và cách tiếp cận lập trình mạng bằng Java.\n2. Vai trò của lập trình mạng Lập trình mạng đóng vai trò nền tảng cho nhiều loại ứng dụng hiện đại:\nỨng dụng thời gian thực: Như chat, video call. Hệ thống phân tán: Quản lý dữ liệu trên nhiều server. Dịch vụ web: REST API, giao diện người dùng qua mạng. Java hỗ trợ mạnh mẽ nhờ các giao thức như TCP/IP và UDP, cùng các công cụ như Socket.\n3. Các khái niệm cơ bản Socket: Là điểm cuối của một kết nối mạng, cho phép gửi và nhận dữ liệu hai chiều giữa client và server. IP và Port: IP xác định thiết bị, Port định danh dịch vụ (ví dụ: Port 80 cho HTTP). Giao thức: TCP: Đảm bảo truyền dữ liệu đáng tin cậy, không mất mát. UDP: Nhanh nhưng không đảm bảo toàn vẹn dữ liệu, phù hợp cho streaming. Client-Server Model: Mô hình phổ biến trong lập trình mạng, nơi server cung cấp dịch vụ và client yêu cầu. 4. Ưu điểm của Java trong lập trình mạng Tính di động: Code Java chạy trên nhiều nền tảng mà không cần chỉnh sửa. Thư viện sẵn có: java.net cung cấp các lớp như ServerSocket, Socket. Bảo mật: Java tích hợp cơ chế bảo vệ kết nối (SSL/TLS). Đa tuyến: Hỗ trợ xử lý nhiều kết nối đồng thời. 5. Ứng dụng thực tế Chat ứng dụng: Như Zalo, WhatsApp dùng mạng để truyền tin nhắn. Server quản lý dữ liệu: Lưu trữ và truy xuất thông tin từ xa. Game online: Đồng bộ trạng thái giữa người chơi qua mạng. 6. Ví dụ minh họa Dưới đây là một chương trình Java cơ bản để lấy thông tin địa chỉ IP:\nimport java.net.*; public class NetworkDemo { public static void main(String[] args) { try { InetAddress localHost = InetAddress.getLocalHost(); System.out.println(\u0026#34;Địa chỉ IP: \u0026#34; + localHost.getHostAddress()); System.out.println(\u0026#34;Tên máy: \u0026#34; + localHost.getHostName()); } catch (UnknownHostException e) { System.out.println(\u0026#34;Lỗi: \u0026#34; + e.getMessage()); } } } ","permalink":"https://nhittt29.github.io/MyTechTales/blog/java/network-overview/","summary":"Khám phá cơ bản về lập trình mạng với Java, nền tảng cho các ứng dụng kết nối qua mạng Internet hoặc nội bộ.","title":"Tổng quan về lập trình mạng"},{"content":"1. Giới thiệu JavaScript, với vai trò ngôn ngữ chính cho lập trình phía client, đã trở thành công cụ không thể thiếu trong việc giao tiếp với server qua mạng.\nCác API như Fetch và XMLHttpRequest cho phép gửi yêu cầu HTTP, tải dữ liệu động, và xây dựng các ứng dụng web tương tác.\nBài viết này, được cập nhật vào ngày 17/10/2025 dựa trên thông tin từ sáng 16/10/2025 lúc 09:40 AM +07, sẽ hướng dẫn chi tiết cách JavaScript xử lý lập trình mạng cơ bản.\n2. Vai trò của JavaScript trong lập trình mạng JavaScript đóng vai trò quan trọng trong việc kết nối phía client với các hệ thống mạng:\nGiao tiếp Client-Server: Gửi yêu cầu đến backend (ví dụ: Java Spring Boot) và nhận phản hồi dưới dạng JSON. Cập nhật giao diện: Tải dữ liệu động mà không cần reload trang, cải thiện trải nghiệm người dùng. Ứng dụng Single Page (SPA): Hỗ trợ framework như React, Vue với giao tiếp mạng liên tục. Thời gian thực: Kết nối WebSocket cho chat hoặc thông báo tức thì. 3. Các công nghệ chính trong lập trình mạng JavaScript JavaScript cung cấp nhiều công cụ để xử lý mạng, bao gồm:\nXMLHttpRequest (XHR): Phương pháp truyền thống, hỗ trợ gửi yêu cầu HTTP bất đồng bộ. Fetch API: API hiện đại dựa trên Promise, dễ sử dụng và tích hợp tốt với async/await. WebSocket: Kết nối hai chiều cho dữ liệu thời gian thực. Server-Sent Events (SSE): Server gửi dữ liệu một chiều đến client, phù hợp cho cập nhật đơn giản. 4. Ưu điểm của JavaScript trong lập trình mạng Bất đồng bộ: Không chặn giao diện người dùng khi chờ phản hồi từ server. Tích hợp linh hoạt: Hoạt động mượt mà với các framework như Angular, React. Hỗ trợ đa dạng: Từ HTTP/HTTPS đến WebSocket, SSE, phù hợp nhiều kịch bản. Cộng đồng lớn: Nhiều thư viện hỗ trợ như Axios, giúp phát triển nhanh chóng. 5. Ứng dụng thực tế API RESTful: Gọi API từ server Java để hiển thị danh sách người dùng hoặc sản phẩm. Tải file: Upload/download tài liệu qua mạng với tiến trình theo dõi. Xác thực người dùng: Gửi thông tin đăng nhập và nhận token xác thực. Bảng điều khiển (Dashboard): Hiển thị dữ liệu thời gian thực từ server, như thống kê bán hàng. 6. Ví dụ minh họa Dưới đây là ví dụ sử dụng Fetch API để gọi REST API và hiển thị dữ liệu:\n// Khởi tạo class để quản lý API class NetworkManager { constructor(baseUrl) { this.baseUrl = baseUrl; } // Hàm GET dữ liệu từ API async getData(endpoint) { try { const response = await fetch(`${this.baseUrl}${endpoint}`, { method: \u0026#39;GET\u0026#39;, headers: { \u0026#39;Accept\u0026#39;: \u0026#39;application/json\u0026#39; } }); if (!response.ok) { throw new Error(`HTTP error! Status: ${response.status}`); } const data = await response.json(); return { success: true, data: data }; } catch (error) { console.error(\u0026#39;Lỗi khi gọi API:\u0026#39;, error); return { success: false, error: error.message }; } } // Hàm POST dữ liệu async postData(endpoint, payload) { try { const response = await fetch(`${this.baseUrl}${endpoint}`, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify(payload) }); if (!response.ok) { throw new Error(\u0026#39;Lỗi khi gửi dữ liệu\u0026#39;); } const result = await response.json(); return { success: true, data: result }; } catch (error) { console.error(\u0026#39;Lỗi POST:\u0026#39;, error); return { success: false, error: error.message }; } } // Hiển thị dữ liệu lên giao diện displayData(data) { const container = document.getElementById(\u0026#39;data-container\u0026#39;); if (container \u0026amp;\u0026amp; data.success) { container.innerHTML = data.data.map(item =\u0026gt; ` \u0026lt;div class=\u0026#34;data-item\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;${item.title || item.name}\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;${item.description || item.email}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; `).join(\u0026#39;\u0026#39;); } else { container.innerHTML = \u0026#39;\u0026lt;p\u0026gt;Không tải được dữ liệu.\u0026lt;/p\u0026gt;\u0026#39;; } } } // Khởi tạo và sử dụng const network = new NetworkManager(\u0026#39;http://localhost:8080/api\u0026#39;); document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, async () =\u0026gt; { const result = await network.getData(\u0026#39;/users\u0026#39;); network.displayData(result); // Ví dụ gửi dữ liệu const form = document.getElementById(\u0026#39;data-form\u0026#39;); if (form) { form.addEventListener(\u0026#39;submit\u0026#39;, async (e) =\u0026gt; { e.preventDefault(); const formData = { name: form.querySelector(\u0026#39;#name\u0026#39;).value, email: form.querySelector(\u0026#39;#email\u0026#39;).value }; const postResult = await network.postData(\u0026#39;/users\u0026#39;, formData); if (postResult.success) { alert(\u0026#39;Dữ liệu đã được gửi thành công!\u0026#39;); form.reset(); } }); } }); ","permalink":"https://nhittt29.github.io/MyTechTales/blog/javascript/js-network/","summary":"Khám phá cách JavaScript thực hiện các yêu cầu mạng cơ bản với Fetch API và XMLHttpRequest, cập nhật ngày 17/10/2025.","title":"JavaScript và lập trình mạng cơ bản"},{"content":"1. Giới thiệu Node.js là một môi trường runtime cho JavaScript, cho phép xây dựng server mạng mạnh mẽ.\nNó đặc biệt phù hợp để xử lý các ứng dụng mạng thời gian thực nhờ mô hình không chặn (non-blocking).\n2. Vai trò trong lập trình mạng Node.js giúp tạo server nhanh chóng, xử lý nhiều kết nối đồng thời.\nNó là lựa chọn phổ biến cho các ứng dụng web và API mạng.\n3. Node.js là gì? Node.js sử dụng động cơ V8 của Chrome, cho phép JavaScript chạy ngoài trình duyệt.\nNó hỗ trợ xử lý I/O không chặn, tối ưu hóa hiệu suất server.\n4. Ứng dụng trong thực tế Xây dựng server chat thời gian thực. Tạo API mạng nhanh chóng. Quản lý lưu lượng truy cập web. 5. Ví dụ minh họa const http = require(\u0026#39;http\u0026#39;); const server = http.createServer((req, res) =\u0026gt; { res.writeHead(200, { \u0026#39;Content-Type\u0026#39;: \u0026#39;text/plain\u0026#39; }); res.end(\u0026#39;Chào mừng đến server Node.js!\u0026#39;); }); server.listen(3000, () =\u0026gt; { console.log(\u0026#39;Server đang chạy tại http://localhost:3000\u0026#39;); }); ","permalink":"https://nhittt29.github.io/MyTechTales/blog/javascript/nodejs-server/","summary":"Hướng dẫn sử dụng Node.js và JavaScript để xây dựng server mạng hiệu quả và tối ưu hóa hiệu suất.","title":"Tối ưu hóa server mạng với Node.js và JavaScript"},{"content":"1. Giới thiệu WebSocket là một giao thức cho phép giao tiếp hai chiều liên tục giữa client và server, lý tưởng cho các ứng dụng cần cập nhật thời gian thực.\nJavaScript cung cấp WebSocket API native để kết nối với server (như Java backend), tạo ra trải nghiệm người dùng mượt mà.\nBài viết này, được cập nhật dựa trên thông tin từ sáng thứ Năm, ngày 16/10/2025 lúc 10:07 AM +07, sẽ hướng dẫn chi tiết cách triển khai WebSocket trong JavaScript.\n2. Vai trò của WebSocket trong ứng dụng web WebSocket đóng vai trò quan trọng trong các ứng dụng hiện đại:\nGiao tiếp hai chiều: Client và server có thể gửi dữ liệu bất cứ lúc nào mà không cần polling. Thời gian thực: Cập nhật tức thì, phù hợp cho chat hoặc thông báo. Tiết kiệm tài nguyên: Giảm số lượng HTTP request so với phương pháp truyền thống. Trải nghiệm tốt: Phản hồi nhanh chóng, nâng cao trải nghiệm người dùng. 3. So sánh với các phương pháp khác Phương pháp Ưu điểm Nhược điểm HTTP Polling Đơn giản, dễ triển khai Nhiều request, hiệu suất thấp Long Polling Gần thời gian thực Vẫn cần nhiều request Server-Sent Events Server gửi dữ liệu một chiều Chỉ hỗ trợ một chiều WebSocket Hai chiều, thời gian thực Phức tạp hơn trong triển khai 4. Cách triển khai WebSocket trong JavaScript JavaScript cung cấp các bước cơ bản để sử dụng WebSocket:\nKết nối: Sử dụng new WebSocket(url) với URL ws:// hoặc wss://. Sự kiện: Xử lý onopen, onmessage, onclose, onerror để theo dõi trạng thái. Gửi dữ liệu: Sử dụng send() để truyền tin nhắn đến server. Đóng kết nối: Gọi close() khi không cần thiết. 5. Ứng dụng thực tế Chat application: Tin nhắn hiển thị tức thì cho tất cả người dùng. Live notification: Thông báo mới đến ngay khi có sự kiện. Real-time dashboard: Cập nhật dữ liệu tài chính hoặc thống kê liên tục. Collaborative editing: Nhiều người chỉnh sửa tài liệu cùng lúc, như Google Docs. 6. Ví dụ minh họa Dưới đây là ví dụ ứng dụng chat sử dụng WebSocket:\n// Class quản lý WebSocket chat class RealTimeChat { constructor(url) { this.socket = new WebSocket(url); this.messages = []; this.init(); } init() { // Xử lý kết nối mở this.socket.onopen = () =\u0026gt; { console.log(\u0026#39;Kết nối WebSocket thành công\u0026#39;); this.updateStatus(\u0026#39;Đã kết nối với server\u0026#39;); }; // Nhận tin nhắn this.socket.onmessage = (event) =\u0026gt; { const message = JSON.parse(event.data); this.addMessage(message); this.renderMessage(message); }; // Xử lý lỗi this.socket.onerror = (error) =\u0026gt; { console.error(\u0026#39;Lỗi WebSocket:\u0026#39;, error); this.updateStatus(\u0026#39;Lỗi kết nối, thử lại sau...\u0026#39;); }; // Xử lý ngắt kết nối this.socket.onclose = (event) =\u0026gt; { console.log(\u0026#39;Kết nối đóng:\u0026#39;, event.code, event.reason); this.updateStatus(\u0026#39;Mất kết nối, đang thử kết nối lại...\u0026#39;); setTimeout(() =\u0026gt; this.reconnect(), 2000); }; // Gửi tin nhắn khi nhấn gửi document.getElementById(\u0026#39;chat-form\u0026#39;).addEventListener(\u0026#39;submit\u0026#39;, (e) =\u0026gt; { e.preventDefault(); this.sendMessage(); }); } sendMessage() { const input = document.getElementById(\u0026#39;message-input\u0026#39;); const message = input.value.trim(); if (message \u0026amp;\u0026amp; this.socket.readyState === WebSocket.OPEN) { const messageData = { type: \u0026#39;chat\u0026#39;, content: message, timestamp: new Date().toISOString(), userId: \u0026#39;user_\u0026#39; + Math.floor(Math.random() * 1000) }; this.socket.send(JSON.stringify(messageData)); input.value = \u0026#39;\u0026#39;; } } addMessage(message) { this.messages.push(message); if (this.messages.length \u0026gt; 50) this.messages.shift(); // Giới hạn 50 tin nhắn } renderMessage(message) { const chatBox = document.getElementById(\u0026#39;chat-box\u0026#39;); const messageDiv = document.createElement(\u0026#39;div\u0026#39;); messageDiv.className = \u0026#39;chat-message\u0026#39;; messageDiv.innerHTML = ` \u0026lt;strong\u0026gt;${message.userId}\u0026lt;/strong\u0026gt;: \u0026lt;span\u0026gt;${message.content}\u0026lt;/span\u0026gt; \u0026lt;small\u0026gt;${new Date(message.timestamp).toLocaleTimeString()}\u0026lt;/small\u0026gt; `; chatBox.appendChild(messageDiv); chatBox.scrollTop = chatBox.scrollHeight; } updateStatus(message) { const status = document.getElementById(\u0026#39;chat-status\u0026#39;); status.textContent = message; status.className = \u0026#39;status\u0026#39;; } reconnect() { if (this.socket.readyState === WebSocket.CLOSED) { this.socket = new WebSocket(this.socket.url); this.init(); } } } // Khởi tạo khi trang tải document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, () =\u0026gt; { new RealTimeChat(\u0026#39;ws://localhost:8080/chat\u0026#39;); }); ","permalink":"https://nhittt29.github.io/MyTechTales/blog/javascript/websocket-js/","summary":"Hướng dẫn sử dụng WebSocket trong JavaScript để xây dựng ứng dụng thời gian thực như chat và thông báo, cập nhật ngày 18/10/2025.","title":"WebSocket với JavaScript cho thời gian thực"},{"content":"1. Giới thiệu JSON (JavaScript Object Notation) là định dạng dữ liệu phổ biến nhất trong giao tiếp giữa client JavaScript và server, đặc biệt khi làm việc với REST API từ backend như Java.\nViệc xử lý JSON hiệu quả giúp đảm bảo dữ liệu chính xác và ứng dụng hoạt động mượt mà.\nBài viết này, được cập nhật dựa trên thông tin từ sáng thứ Năm, ngày 16/10/2025 lúc 09:56 AM +07, sẽ hướng dẫn chi tiết cách làm việc với JSON trong lập trình mạng JavaScript.\n2. Vai trò của JSON trong lập trình mạng JSON đóng vai trò quan trọng trong các ứng dụng mạng hiện đại:\nĐịnh dạng chuẩn: Là ngôn ngữ trung lập, dễ đọc và parse, được hỗ trợ bởi hầu hết các ngôn ngữ lập trình. Tích hợp tốt: JavaScript có thể parse JSON native mà không cần thư viện bổ sung. Nhẹ và nhanh: Kích thước nhỏ, parse nhanh hơn so với XML. Cấu trúc linh hoạt: Hỗ trợ object, array, và dữ liệu lồng nhau (nested data). 3. Cấu trúc JSON cơ bản Dưới đây là ví dụ về cấu trúc JSON điển hình:\n{ \u0026#34;user\u0026#34;: { \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;Nguyen Van A\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;a@example.com\u0026#34;, \u0026#34;profile\u0026#34;: { \u0026#34;age\u0026#34;: 25, \u0026#34;city\u0026#34;: \u0026#34;Ha Noi\u0026#34; }, \u0026#34;hobbies\u0026#34;: [\u0026#34;reading\u0026#34;, \u0026#34;coding\u0026#34;, \u0026#34;gaming\u0026#34;] }, \u0026#34;status\u0026#34;: \u0026#34;active\u0026#34;, \u0026#34;timestamp\u0026#34;: \u0026#34;2025-10-19T09:00:00Z\u0026#34; } ","permalink":"https://nhittt29.github.io/MyTechTales/blog/javascript/json-js/","summary":"Hướng dẫn xử lý dữ liệu JSON trong JavaScript khi giao tiếp với API mạng, cập nhật ngày 19/10/2025.","title":"Xử lý dữ liệu JSON với JavaScript trong mạng"}]